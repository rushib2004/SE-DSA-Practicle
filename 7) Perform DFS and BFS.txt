#include <iostream>
#include <cstring>
#include <cstdlib> // For exit()

using namespace std;

struct Vertex {
    char name[15];
    int visit;
    struct Vertex *next;
};

struct Vertex *lmark[20];

struct Vertex *newNode(char nm[15]) {
    struct Vertex *p = (struct Vertex *)malloc(sizeof(struct Vertex));
    if (p == nullptr) {
        cerr << "Memory allocation failed!" << endl;
        exit(EXIT_FAILURE);
    }
    strcpy(p->name, nm);
    p->visit = 0;
    p->next = nullptr;
    return p;
}

int search(char x[15], int n) {
    int i;
    for (i = 0; i < n; i++) {
        if (strcmp(lmark[i]->name, x) == 0)
            return i;
    }
    return -1; // Not found
}

void DFS(char s[15], int n) {
    struct Vertex *temp;
    char stack[20][15], x[15];
    int top = -1, i;
    cout << endl << "DFS of given graph is" << endl;
    top++;
    strcpy(stack[top], s); // Push
    while (top != -1) {
        strcpy(x, stack[top]); // Pop
        top--;
        i = search(x, n);
        if (lmark[i]->visit == 0) {
            cout << lmark[i]->name << endl;
            lmark[i]->visit = 1;
        } else
            continue;
        temp = lmark[i]->next;
        while (temp != nullptr) {
            i = search(temp->name, n);
            if (lmark[i]->visit == 0) {
                top++;
                strcpy(stack[top], temp->name);
            }
            temp = temp->next;
        }
    }
}

void BFS(char s[15], int n) {
    struct Vertex *temp;
    char Queue[20][15], x[15];
    int front = -1, rear = -1, i;
    cout << endl << "BFS of given graph is" << endl;
    if (rear == -1)
        front++;
    rear++;
    strcpy(Queue[rear], s); // Insert in queue
    while (rear != -1) {
        strcpy(x, Queue[front]); // Delete from queue
        front++;
        if (front > rear)
            front = rear = -1;
        i = search(x, n);
        if (lmark[i]->visit == 0) {
            cout << lmark[i]->name << endl;
            lmark[i]->visit = 1;
        } else
            continue;
        temp = lmark[i]->next;
        while (temp != nullptr) {
            i = search(temp->name, n);
            if (lmark[i]->visit == 0) {
                if (rear == 0)
                    front = 0;
                rear++;
                strcpy(Queue[rear], temp->name);
            }
            temp = temp->next;
        }
    }
}

int main() {
    int n, e, i, i1, i2, choice;
    char v1[15], v2[15], s[15], nm[15];
    struct Vertex *p, *q, *temp;
    cout << "Enter number of vertices: ";
    cin >> n;
    for (i = 0; i < n; i++) {
        cout << "Enter name of vertex " << i + 1 << ": ";
        cin >> nm;
        p = newNode(nm);
        lmark[i] = p;
    }
    cout << "Enter number of edges: ";
    cin >> e;
    for (i = 0; i < e; i++) {
        cout << "Enter edge " << i + 1 << ": ";
        cin >> v1 >> v2;
        i1 = search(v1, n);
        i2 = search(v2, n);
        if (i1 != -1 && i2 != -1) {
            p = newNode(v2);
            q = newNode(v1);
            temp = lmark[i1];
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = p;
            temp = lmark[i2];
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = q;
        } else {
            cout << "Invalid edge input!" << endl;
            return 1; // Error exit
        }
    }
    cout << endl << "Adjacency list is" << endl;
    for (i = 0; i < n; i++) {
        temp = lmark[i];
        while (temp != nullptr) {
            cout << temp->name << "->";
            temp = temp->next;
        }
        cout << endl;
    }
    cout << endl << "Enter starting node: ";
    cin >> s;
    cout << endl;
    while (true) {
        cout << "\nMenu:\n 1. DFS\n 2. BFS\n 3. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;
        switch (choice) {
            case 1:
                for (i = 0; i < n; i++) {
                    lmark[i]->visit = 0;
                }
                DFS(s, n);
                break;
            case 2:
                for (i = 0; i < n; i++) {
                    lmark[i]->visit = 0;
                }
                BFS(s, n);
                break;
            case 3:
                return 0; // Normal exit
            default:
                cout << "Invalid choice!" << endl;
        }
    }
    return 0;
}
